From 7d932f474afb171cc983d355e4619c5e034f7641 Mon Sep 17 00:00:00 2001
From: Lina Chen <chenln1124@thundersoft.com>
Date: Wed, 18 Jan 2023 08:27:56 +0000
Subject: [PATCH 4/5] Modify net_sockets.c

---
 include/mbedtls/mbedtls_config.h |   8 +-
 library/CMakeLists.txt           |   1 +
 library/entropy_alt.c            |  70 ++++
 library/net_sockets.c            | 604 +++++++++----------------------
 4 files changed, 254 insertions(+), 429 deletions(-)
 mode change 100644 => 100755 library/CMakeLists.txt
 create mode 100755 library/entropy_alt.c

diff --git a/include/mbedtls/mbedtls_config.h b/include/mbedtls/mbedtls_config.h
index 985c02cf1..b1003d2e9 100755
--- a/include/mbedtls/mbedtls_config.h
+++ b/include/mbedtls/mbedtls_config.h
@@ -473,7 +473,7 @@
  *
  * Uncomment to use your own hardware entropy collector.
  */
-//#define MBEDTLS_ENTROPY_HARDWARE_ALT
+#define MBEDTLS_ENTROPY_HARDWARE_ALT
 
 /**
  * \def MBEDTLS_AES_ROM_TABLES
@@ -493,7 +493,7 @@
  * This option is independent of \c MBEDTLS_AES_FEWER_TABLES.
  *
  */
-//#define MBEDTLS_AES_ROM_TABLES
+#define MBEDTLS_AES_ROM_TABLES
 
 /**
  * \def MBEDTLS_AES_FEWER_TABLES
@@ -1049,7 +1049,7 @@
  * This option is only useful if both MBEDTLS_SHA256_C and
  * MBEDTLS_SHA512_C are defined. Otherwise the available hash module is used.
  */
-//#define MBEDTLS_ENTROPY_FORCE_SHA256
+#define MBEDTLS_ENTROPY_FORCE_SHA256
 
 /**
  * \def MBEDTLS_ENTROPY_NV_SEED
@@ -2501,7 +2501,7 @@
  *
  * This module provides networking routines.
  */
-//#define MBEDTLS_NET_C
+#define MBEDTLS_NET_C
 
 /**
  * \def MBEDTLS_OID_C
diff --git a/library/CMakeLists.txt b/library/CMakeLists.txt
old mode 100644
new mode 100755
index 0884f57ae..6b0b45084
--- a/library/CMakeLists.txt
+++ b/library/CMakeLists.txt
@@ -34,6 +34,7 @@ set(src_crypto
     ecjpake.c
     ecp.c
     ecp_curves.c
+    entropy_alt.c
     entropy.c
     entropy_poll.c
     error.c
diff --git a/library/entropy_alt.c b/library/entropy_alt.c
new file mode 100755
index 000000000..f3a5ea6e4
--- /dev/null
+++ b/library/entropy_alt.c
@@ -0,0 +1,70 @@
+/*
+ *  Entropy accumulator implementation
+ *
+ *  Copyright (C) 2006-2016, ARM Limited, All Rights Reserved
+ *  SPDX-License-Identifier: Apache-2.0
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
+ *  not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ *  This file is part of mbed TLS (https://tls.mbed.org)
+ */
+
+#if !defined(MBEDTLS_CONFIG_FILE)
+#include "mbedtls/mbedtls_config.h"
+#else
+#include MBEDTLS_CONFIG_FILE
+#endif
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "entropy_poll.h"
+
+#if defined(MBEDTLS_ENTROPY_C)
+
+#if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
+
+
+static int get_random_bytes(void *buf, unsigned int len)
+{
+    unsigned int ranbuf;
+    unsigned int *lp;
+    int i, count;
+    count = len / sizeof(unsigned int);
+    lp = (unsigned int *) buf;
+
+    for (i = 0; i < count; i ++) {
+        lp[i] = rand();
+        len -= sizeof(unsigned int);
+    }
+
+    if (len > 0) {
+        ranbuf = rand();
+        memcpy(&lp[i], &ranbuf, len);
+    }
+    return 0;
+}
+
+int mbedtls_hardware_poll( void *data,
+                           unsigned char *output, size_t len, size_t *olen )
+{
+    (void)data;
+    get_random_bytes(output, len);
+    *olen = len;
+    return 0;
+}
+#endif /* MBEDTLS_ENTROPY_HARDWARE_ALT */
+
+#endif /* MBEDTLS_ENTROPY_C */
diff --git a/library/net_sockets.c b/library/net_sockets.c
index 0d799e398..486af6ff7 100755
--- a/library/net_sockets.c
+++ b/library/net_sockets.c
@@ -30,12 +30,13 @@
 #include "common.h"
 
 #if defined(MBEDTLS_NET_C)
-
+/*
 #if !defined(unix) && !defined(__unix__) && !defined(__unix) && \
     !defined(__APPLE__) && !defined(_WIN32) && !defined(__QNXNTO__) && \
     !defined(__HAIKU__) && !defined(__midipix__)
 #error "This module only works on Unix and Windows, see MBEDTLS_NET_C in mbedtls_config.h"
 #endif
+*/
 
 #if defined(MBEDTLS_PLATFORM_C)
 #include "mbedtls/platform.h"
@@ -80,6 +81,26 @@
 
 static int wsa_init_done = 0;
 
+#elif defined(__ICCARM__) || defined(__CC_ARM) || defined ( __GNUC__ )
+
+#include "lwip/sockets.h"
+#include "lwip/inet.h"
+#if LWIP_DNS
+#include "lwip/netdb.h"
+#endif
+#include <errno.h>
+
+#define net_htons(n) htons(n)
+#define net_htonl(n) htonl(n)
+
+#define IS_EINTR( ret ) ( ( ret ) == EINTR )
+
+#define read        lwip_read
+#define write       lwip_write
+#define select      lwip_select
+#define poll        lwip_poll
+#define close       lwip_close
+
 #else /* ( _WIN32 || _WIN32_WCE ) && !EFIX64 && !EFI32 */
 
 #include <sys/types.h>
@@ -130,7 +151,7 @@ static int net_prepare( void )
         wsa_init_done = 1;
     }
 #else
-#if !defined(EFIX64) && !defined(EFI32)
+#if !defined(EFIX64) && !defined(EFI32) && !defined(__ICCARM__) && !defined(__CC_ARM) &&  !defined ( __GNUC__ )
     signal( SIGPIPE, SIG_IGN );
 #endif
 #endif
@@ -176,6 +197,7 @@ void mbedtls_net_init( mbedtls_net_context *ctx )
 int mbedtls_net_connect( mbedtls_net_context *ctx, const char *host,
                          const char *port, int proto )
 {
+#if defined(MBEDTLS_HAVE_IPV6)
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     struct addrinfo hints, *addr_list, *cur;
 
@@ -216,6 +238,51 @@ int mbedtls_net_connect( mbedtls_net_context *ctx, const char *host,
     freeaddrinfo( addr_list );
 
     return( ret );
+#else
+    /* Legacy IPv4-only version */
+
+    int ret;
+    int type, protocol;
+    struct sockaddr_in server_addr;
+#if LWIP_DNS
+    struct hostent *server_host;
+#endif
+    if( ( ret = net_prepare() ) != 0 )
+        return( ret );
+
+    type = ( proto == MBEDTLS_NET_PROTO_UDP ) ? SOCK_DGRAM : SOCK_STREAM;
+    protocol = ( proto == MBEDTLS_NET_PROTO_UDP ) ? IPPROTO_UDP : IPPROTO_TCP;
+
+#if LWIP_DNS
+    if( ( server_host = gethostbyname( host ) ) == NULL )
+        return( MBEDTLS_ERR_NET_UNKNOWN_HOST );
+
+    if( ( ctx->fd = (int) socket( AF_INET, type, protocol ) ) < 0 )
+        return( MBEDTLS_ERR_NET_SOCKET_FAILED );
+
+    memcpy( (void *) &server_addr.sin_addr,
+            (void *) server_host->h_addr,
+                     4 );
+#else
+    if( ( ctx->fd = (int) socket( AF_INET, type, protocol ) ) < 0 )
+        return( MBEDTLS_ERR_NET_SOCKET_FAILED );
+
+    server_addr.sin_len = sizeof(server_addr);
+    server_addr.sin_addr.s_addr = inet_addr(host);
+#endif
+
+    server_addr.sin_family = AF_INET;
+    server_addr.sin_port   = net_htons( atoi(port) );
+
+    if( connect( ctx->fd, (struct sockaddr *) &server_addr,
+                 sizeof( server_addr ) ) < 0 )
+    {
+        close( ctx->fd );
+        return( MBEDTLS_ERR_NET_CONNECT_FAILED );
+    }
+
+    return( 0 );
+#endif /* MBEDTLS_HAVE_IPV6 */
 }
 
 /*
@@ -223,6 +290,7 @@ int mbedtls_net_connect( mbedtls_net_context *ctx, const char *host,
  */
 int mbedtls_net_bind( mbedtls_net_context *ctx, const char *bind_ip, const char *port, int proto )
 {
+#if defined(MBEDTLS_HAVE_IPV6)
     int n, ret;
     struct addrinfo hints, *addr_list, *cur;
 
@@ -287,7 +355,66 @@ int mbedtls_net_bind( mbedtls_net_context *ctx, const char *bind_ip, const char
     freeaddrinfo( addr_list );
 
     return( ret );
+#else
+    /* Legacy IPv4-only version */
+
+    int ret, n, c[4];
+    int type, protocol;
+    struct sockaddr_in server_addr;
+
+    if( ( ret = net_prepare() ) != 0 )
+        return( ret );
 
+    type = ( proto == MBEDTLS_NET_PROTO_UDP ) ? SOCK_DGRAM : SOCK_STREAM;
+    protocol = ( proto == MBEDTLS_NET_PROTO_UDP ) ? IPPROTO_UDP : IPPROTO_TCP;
+
+    if( ( ctx->fd = (int) socket( AF_INET, type, protocol ) ) < 0 )
+        return( MBEDTLS_ERR_NET_SOCKET_FAILED );
+
+    n = 1;
+    setsockopt( ctx->fd, SOL_SOCKET, SO_REUSEADDR,
+                (const char *) &n, sizeof( n ) );
+
+    server_addr.sin_addr.s_addr = net_htonl( INADDR_ANY );
+    server_addr.sin_family      = AF_INET;
+    server_addr.sin_port        = net_htons( atoi(port) );
+
+    if( bind_ip != NULL )
+    {
+        memset( c, 0, sizeof( c ) );
+        sscanf( bind_ip, "%d.%d.%d.%d", &c[0], &c[1], &c[2], &c[3] );
+
+        for( n = 0; n < 4; n++ )
+            if( c[n] < 0 || c[n] > 255 )
+                break;
+
+        if( n == 4 )
+            server_addr.sin_addr.s_addr = net_htonl(
+                ( (uint32_t) c[0] << 24 ) |
+                ( (uint32_t) c[1] << 16 ) |
+                ( (uint32_t) c[2] <<  8 ) |
+                ( (uint32_t) c[3]       ) );
+    }
+
+    if( bind( ctx->fd, (struct sockaddr *) &server_addr,
+              sizeof( server_addr ) ) < 0 )
+    {
+        close( ctx->fd );
+        return( MBEDTLS_ERR_NET_BIND_FAILED );
+    }
+
+    /* Listen only makes sense for TCP */
+    if( proto == MBEDTLS_NET_PROTO_TCP )
+    {
+        if( listen( ctx->fd, MBEDTLS_NET_LISTEN_BACKLOG ) != 0 )
+        {
+            close( ctx->fd );
+            return( MBEDTLS_ERR_NET_LISTEN_FAILED );
+        }
+    }
+
+    return( 0 );
+#endif /* MBEDTLS_HAVE_IPV6 */
 }
 
 #if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
@@ -310,12 +437,16 @@ static int net_would_block( const mbedtls_net_context *ctx )
  */
 static int net_would_block( const mbedtls_net_context *ctx )
 {
+    /* To avoid gcc warnings */
+    ( void ) ctx;
+
+#ifdef ERRNO
     int err = errno;
 
     /*
      * Never return 'WOULD BLOCK' on a blocking socket
      */
-    if( ( fcntl( ctx->fd, F_GETFL ) & O_NONBLOCK ) != O_NONBLOCK )
+    if( ( fcntl( ctx->fd, F_GETFL, 0 ) & O_NONBLOCK ) != O_NONBLOCK )
     {
         errno = err;
         return( 0 );
@@ -331,6 +462,7 @@ static int net_would_block( const mbedtls_net_context *ctx )
 #endif
             return( 1 );
     }
+#endif
     return( 0 );
 }
 #endif /* ( _WIN32 || _WIN32_WCE ) && !EFIX64 && !EFI32 */
@@ -345,7 +477,11 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
     int type;
 
+#if defined(MBEDTLS_HAVE_IPV6)
     struct sockaddr_storage client_addr;
+#else
+    struct sockaddr_in client_addr;
+#endif
 
 #if defined(__socklen_t_defined) || defined(_SOCKLEN_T) ||  \
     defined(_SOCKLEN_T_DECLARED) || defined(__DEFINED_socklen_t) || \
@@ -359,7 +495,7 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
 
     /* Is this a TCP or UDP socket? */
     if( getsockopt( bind_ctx->fd, SOL_SOCKET, SO_TYPE,
-                    (void *) &type, &type_len ) != 0 ||
+                    (void *) &type, (u32_t*)&type_len ) != 0 ||
         ( type != SOCK_STREAM && type != SOCK_DGRAM ) )
     {
         return( MBEDTLS_ERR_NET_ACCEPT_FAILED );
@@ -369,7 +505,7 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
     {
         /* TCP: actual accept() */
         ret = client_ctx->fd = (int) accept( bind_ctx->fd,
-                                             (struct sockaddr *) &client_addr, &n );
+                                             (struct sockaddr *) &client_addr, (u32_t*)&n );
     }
     else
     {
@@ -377,7 +513,7 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
         char buf[1] = { 0 };
 
         ret = (int) recvfrom( bind_ctx->fd, buf, sizeof( buf ), MSG_PEEK,
-                        (struct sockaddr *) &client_addr, &n );
+                        (struct sockaddr *) &client_addr, (u32_t*)&n );
 
 #if defined(_WIN32)
         if( ret == SOCKET_ERROR &&
@@ -401,7 +537,12 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
      * then bind a new socket to accept new connections */
     if( type != SOCK_STREAM )
     {
+#if defined(MBEDTLS_HAVE_IPV6)
         struct sockaddr_storage local_addr;
+#else
+        struct sockaddr_in local_addr;
+#endif
+
         int one = 1;
 
         if( connect( bind_ctx->fd, (struct sockaddr *) &client_addr, n ) != 0 )
@@ -410,6 +551,7 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
         client_ctx->fd = bind_ctx->fd;
         bind_ctx->fd   = -1; /* In case we exit early */
 
+#if defined(MBEDTLS_HAVE_IPV6)
         n = sizeof( struct sockaddr_storage );
         if( getsockname( client_ctx->fd,
                          (struct sockaddr *) &local_addr, &n ) != 0 ||
@@ -420,6 +562,18 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
         {
             return( MBEDTLS_ERR_NET_SOCKET_FAILED );
         }
+#else
+        n = sizeof( struct sockaddr_in );
+        if( getsockname( client_ctx->fd,
+                         (struct sockaddr *) &local_addr, (u32_t*)&n ) != 0 ||
+            ( bind_ctx->fd = (int) socket( local_addr.sin_family,
+                                           SOCK_DGRAM, IPPROTO_UDP ) ) < 0 ||
+            setsockopt( bind_ctx->fd, SOL_SOCKET, SO_REUSEADDR,
+                        (const char *) &one, sizeof( one ) ) != 0 )
+        {
+            return( MBEDTLS_ERR_NET_SOCKET_FAILED );
+        }
+#endif
 
         if( bind( bind_ctx->fd, (struct sockaddr *) &local_addr, n ) != 0 )
         {
@@ -429,6 +583,7 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
 
     if( client_ip != NULL )
     {
+#if defined(MBEDTLS_HAVE_IPV6)
         if( client_addr.ss_family == AF_INET )
         {
             struct sockaddr_in *addr4 = (struct sockaddr_in *) &client_addr;
@@ -449,6 +604,14 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
 
             memcpy( client_ip, &addr6->sin6_addr.s6_addr, *ip_len);
         }
+#else
+        *ip_len = sizeof( client_addr.sin_addr.s_addr );
+
+        if( buf_size < *ip_len )
+            return( MBEDTLS_ERR_NET_BUFFER_TOO_SMALL );
+
+        memcpy( client_ip, &client_addr.sin_addr.s_addr, *ip_len );
+#endif /* MBEDTLS_HAVE_IPV6 */
     }
 
     return( 0 );
@@ -459,9 +622,9 @@ int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
  */
 int mbedtls_net_set_block( mbedtls_net_context *ctx )
 {
-#if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
+#if ( defined(_WIN32) || defined(_WIN32_WCE) || defined(__ICCARM__) || defined(__CC_ARM)  || defined ( __GNUC__ ) ) && !defined(EFIX64) && \
     !defined(EFI32)
-    u_long n = 0;
+    unsigned long n = 0;
     return( ioctlsocket( ctx->fd, FIONBIO, &n ) );
 #else
     return( fcntl( ctx->fd, F_SETFL, fcntl( ctx->fd, F_GETFL ) & ~O_NONBLOCK ) );
@@ -470,9 +633,9 @@ int mbedtls_net_set_block( mbedtls_net_context *ctx )
 
 int mbedtls_net_set_nonblock( mbedtls_net_context *ctx )
 {
-#if ( defined(_WIN32) || defined(_WIN32_WCE) ) && !defined(EFIX64) && \
+#if ( defined(_WIN32) || defined(_WIN32_WCE) || defined(__ICCARM__) || defined(__CC_ARM)  || defined ( __GNUC__ ) ) && !defined(EFIX64) && \
     !defined(EFI32)
-    u_long n = 1;
+    unsigned long n = 1;
     return( ioctlsocket( ctx->fd, FIONBIO, &n ) );
 #else
     return( fcntl( ctx->fd, F_SETFL, fcntl( ctx->fd, F_GETFL ) | O_NONBLOCK ) );
@@ -590,13 +753,14 @@ int mbedtls_net_recv( void *ctx, unsigned char *buf, size_t len )
         if( WSAGetLastError() == WSAECONNRESET )
             return( MBEDTLS_ERR_NET_CONN_RESET );
 #else
+#ifdef ERRNO
         if( errno == EPIPE || errno == ECONNRESET )
             return( MBEDTLS_ERR_NET_CONN_RESET );
 
         if( errno == EINTR )
             return( MBEDTLS_ERR_SSL_WANT_READ );
 #endif
-
+#endif
         return( MBEDTLS_ERR_NET_RECV_FAILED );
     }
 
@@ -637,10 +801,11 @@ int mbedtls_net_recv_timeout( void *ctx, unsigned char *buf,
         if( WSAGetLastError() == WSAEINTR )
             return( MBEDTLS_ERR_SSL_WANT_READ );
 #else
+#ifdef ERRNO
         if( errno == EINTR )
             return( MBEDTLS_ERR_SSL_WANT_READ );
 #endif
-
+#endif
         return( MBEDTLS_ERR_NET_RECV_FAILED );
     }
 
@@ -672,11 +837,13 @@ int mbedtls_net_send( void *ctx, const unsigned char *buf, size_t len )
         if( WSAGetLastError() == WSAECONNRESET )
             return( MBEDTLS_ERR_NET_CONN_RESET );
 #else
+#ifdef ERRNO
         if( errno == EPIPE || errno == ECONNRESET )
             return( MBEDTLS_ERR_NET_CONN_RESET );
 
         if( errno == EINTR )
             return( MBEDTLS_ERR_SSL_WANT_WRITE );
+#endif
 #endif
 
         return( MBEDTLS_ERR_NET_SEND_FAILED );
@@ -712,418 +879,5 @@ void mbedtls_net_free( mbedtls_net_context *ctx )
     ctx->fd = -1;
 }
 
-#else
-#if defined(MBEDTLS_PLATFORM_C)
-#include "mbedtls/platform.h"
-#else
-#include <stdlib.h>
-#define mbedtls_calloc    calloc
-#define mbedtls_free      free
-#define mbedtls_time      time
-#define mbedtls_time_t    time_t
-#endif
-
-#include "mbedtls/net_sockets.h"
-
-#include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-#include <netdb.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <stdint.h>
-
-/*
- * Prepare for using the sockets interface
- */
-static int net_prepare( void )
-{
-    return ( 0 );
-}
-
-/*
- * Initialize a context
- */
-void mbedtls_net_init( mbedtls_net_context *ctx )
-{
-    ctx->fd = -1;
-}
-
-/*
- * Initiate a TCP connection with host:port and the given protocol
- */
-int mbedtls_net_connect( mbedtls_net_context *ctx, const char *host, const char *port, int proto )
-{
-    int ret;
-    struct addrinfo hints, *addr_list, *cur;
-
-    if ( ( ret = net_prepare() ) != 0 ) {
-        return ( ret );
-    }
-
-    /* Do name resolution with both IPv6 and IPv4 */
-    memset( &hints, 0, sizeof( hints ) );
-    hints.ai_family = AF_UNSPEC;
-    hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;
-    hints.ai_protocol = proto == MBEDTLS_NET_PROTO_UDP ? IPPROTO_UDP : IPPROTO_TCP;
-
-    if ( getaddrinfo( host, port, &hints, &addr_list ) != 0 ) {
-        return ( MBEDTLS_ERR_NET_UNKNOWN_HOST );
-    }
-
-    /* Try the sockaddrs until a connection succeeds */
-    ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;
-    for ( cur = addr_list; cur != NULL; cur = cur->ai_next ) {
-        int fd = socket( cur->ai_family, cur->ai_socktype, cur->ai_protocol );
-
-        if ( fd < 0 ) {
-            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;
-            continue;
-        }
-
-        if ( connect( fd, cur->ai_addr, cur->ai_addrlen ) == 0 ) {
-            ctx->fd = fd; // connected!
-            ret = 0;
-            break;
-        }
-
-        close( fd );
-        ret = MBEDTLS_ERR_NET_CONNECT_FAILED;
-    }
-
-    freeaddrinfo( addr_list );
-
-    return ( ret );
-}
-
-/*
- * Create a listening socket on bind_ip:port
- */
-int mbedtls_net_bind( mbedtls_net_context *ctx, const char *bind_ip, const char *port, int proto )
-{
-    int ret;
-    struct addrinfo hints, *addr_list, *cur;
-    struct sockaddr_in *serv_addr = NULL;
-#if SO_REUSE
-    int n = 1;
-#endif
-
-    if ( ( ret = net_prepare() ) != 0 ) {
-        return ( ret );
-    }
-
-    /* Bind to IPv6 and/or IPv4, but only in the desired protocol */
-    memset( &hints, 0, sizeof( hints ) );
-    hints.ai_family = AF_UNSPEC;
-    hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;
-    hints.ai_protocol = proto == MBEDTLS_NET_PROTO_UDP ? IPPROTO_UDP : IPPROTO_TCP;
-
-    if ( getaddrinfo( bind_ip, port, &hints, &addr_list ) != 0 ) {
-        return ( MBEDTLS_ERR_NET_UNKNOWN_HOST );
-    }
-
-    /* Try the sockaddrs until a binding succeeds */
-    ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;
-    for ( cur = addr_list; cur != NULL; cur = cur->ai_next ) {
-        int fd = socket( cur->ai_family, cur->ai_socktype, cur->ai_protocol );
-        if ( fd < 0 ) {
-            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;
-            continue;
-        }
-
-        /*SO_REUSEADDR option dafault is disable in source code(lwip)*/
-#if SO_REUSE
-        if ( setsockopt( fd, SOL_SOCKET, SO_REUSEADDR,
-                         (const char *) &n, sizeof( n ) ) != 0 ) {
-            close( fd );
-            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;
-            continue;
-        }
-#endif
-        /*bind interface dafault don't process the addr is 0xffffffff for TCP Protocol*/
-        serv_addr = (struct sockaddr_in *)cur->ai_addr;
-        serv_addr->sin_addr.s_addr = htonl(INADDR_ANY); /* Any incoming interface */
-        if ( bind( fd, (struct sockaddr *)serv_addr, cur->ai_addrlen ) != 0 ) {
-            close( fd );
-            ret = MBEDTLS_ERR_NET_BIND_FAILED;
-            continue;
-        }
-
-        /* Listen only makes sense for TCP */
-        if ( proto == MBEDTLS_NET_PROTO_TCP ) {
-            if ( listen( fd, MBEDTLS_NET_LISTEN_BACKLOG ) != 0 ) {
-                close( fd );
-                ret = MBEDTLS_ERR_NET_LISTEN_FAILED;
-                continue;
-            }
-        }
-
-        /* I we ever get there, it's a success */
-        ctx->fd = fd;
-        ret = 0;
-        break;
-    }
-
-    freeaddrinfo( addr_list );
-
-    return ( ret );
-
-}
-
-/*
- * Check if the requested operation would be blocking on a non-blocking socket
- * and thus 'failed' with a negative return value.
- *
- * Note: on a blocking socket this function always returns 0!
- */
-static int net_would_block( const mbedtls_net_context *ctx )
-{
-    int error = errno;
-    // no use ctx
-    ( void )ctx;
-
-    switch ( errno = error ) {
-#if defined EAGAIN
-    case EAGAIN:
-#endif
-#if defined EWOULDBLOCK && EWOULDBLOCK != EAGAIN
-    case EWOULDBLOCK:
-#endif
-        return ( 1 );
-    }
-    return ( 0 );
-}
-
-/*
- * Accept a connection from a remote client
- */
-int mbedtls_net_accept( mbedtls_net_context *bind_ctx,
-                        mbedtls_net_context *client_ctx,
-                        void *client_ip, size_t buf_size, size_t *ip_len )
-{
-    int ret;
-    int type;
-
-    struct sockaddr_in client_addr;
-
-    socklen_t n = (socklen_t) sizeof( client_addr );
-    socklen_t type_len = (socklen_t) sizeof( type );
-
-    /* Is this a TCP or UDP socket? */
-    if ( getsockopt( bind_ctx->fd, SOL_SOCKET, SO_TYPE,
-                     (void *) &type, (socklen_t *) &type_len ) != 0 ||
-            ( type != SOCK_STREAM && type != SOCK_DGRAM ) ) {
-        return ( MBEDTLS_ERR_NET_ACCEPT_FAILED );
-    }
-
-    if ( type == SOCK_STREAM ) {
-        /* TCP: actual accept() */
-        ret = client_ctx->fd = (int) accept( bind_ctx->fd,
-                                             (struct sockaddr *) &client_addr, &n );
-    } else {
-        /* UDP: wait for a message, but keep it in the queue */
-        char buf[1] = { 0 };
-
-        ret = recvfrom( bind_ctx->fd, buf, sizeof( buf ), MSG_PEEK,
-                        (struct sockaddr *) &client_addr, &n );
-
-    }
-
-    if ( ret < 0 ) {
-        if ( net_would_block( bind_ctx ) != 0 ) {
-            return ( MBEDTLS_ERR_SSL_WANT_READ );
-        }
-
-        return ( MBEDTLS_ERR_NET_ACCEPT_FAILED );
-    }
-
-    /* UDP: hijack the listening socket to communicate with the client,
-     * then bind a new socket to accept new connections */
-    if ( type != SOCK_STREAM ) {
-        struct sockaddr_in local_addr;
-        int one = 1;
-
-        if ( connect( bind_ctx->fd, (struct sockaddr *) &client_addr, n ) != 0 ) {
-            return ( MBEDTLS_ERR_NET_ACCEPT_FAILED );
-        }
-
-        client_ctx->fd = bind_ctx->fd;
-        bind_ctx->fd   = -1; /* In case we exit early */
-
-        n = sizeof( struct sockaddr_in );
-        if ( getsockname( client_ctx->fd,
-                          (struct sockaddr *) &local_addr, &n ) != 0 ||
-                ( bind_ctx->fd = (int) socket( AF_INET,
-                                               SOCK_DGRAM, IPPROTO_UDP ) ) < 0 ||
-                setsockopt( bind_ctx->fd, SOL_SOCKET, SO_REUSEADDR,
-                            (const char *) &one, sizeof( one ) ) != 0 ) {
-            return ( MBEDTLS_ERR_NET_SOCKET_FAILED );
-        }
-
-        if ( bind( bind_ctx->fd, (struct sockaddr *) &local_addr, n ) != 0 ) {
-            return ( MBEDTLS_ERR_NET_BIND_FAILED );
-        }
-    }
-
-    if ( client_ip != NULL ) {
-        struct sockaddr_in *addr4 = (struct sockaddr_in *) &client_addr;
-        *ip_len = sizeof( addr4->sin_addr.s_addr );
-
-        if ( buf_size < *ip_len ) {
-            return ( MBEDTLS_ERR_NET_BUFFER_TOO_SMALL );
-        }
-
-        memcpy( client_ip, &addr4->sin_addr.s_addr, *ip_len );
-    }
-
-    return ( 0 );
-}
-
-/*
- * Set the socket blocking or non-blocking
- */
-int mbedtls_net_set_block( mbedtls_net_context *ctx )
-{
-    return ( fcntl( ctx->fd, F_SETFL, fcntl( ctx->fd, F_GETFL, 0 ) & ~O_NONBLOCK ) );
-}
-
-int mbedtls_net_set_nonblock( mbedtls_net_context *ctx )
-{
-    return ( fcntl( ctx->fd, F_SETFL, fcntl( ctx->fd, F_GETFL, 0 ) | O_NONBLOCK ) );
-}
-
-/*
- * Portable usleep helper
- */
-void mbedtls_net_usleep( unsigned long usec )
-{
-    struct timeval tv;
-    tv.tv_sec  = usec / 1000000;
-    tv.tv_usec = usec % 1000000;
-    select( 0, NULL, NULL, NULL, &tv );
-}
-
-/*
- * Read at most 'len' characters
- */
-int mbedtls_net_recv( void *ctx, unsigned char *buf, size_t len )
-{
-    int ret;
-    int fd = ((mbedtls_net_context *) ctx)->fd;
-
-    if ( fd < 0 ) {
-        return ( MBEDTLS_ERR_NET_INVALID_CONTEXT );
-    }
-
-    ret = (int) read( fd, buf, len );
-
-    if ( ret < 0 ) {
-        if ( net_would_block( ctx ) != 0 ) {
-            return ( MBEDTLS_ERR_SSL_WANT_READ );
-        }
-
-        if ( errno == EPIPE || errno == ECONNRESET ) {
-            return ( MBEDTLS_ERR_NET_CONN_RESET );
-        }
-
-        if ( errno == EINTR ) {
-            return ( MBEDTLS_ERR_SSL_WANT_READ );
-        }
-
-        return ( MBEDTLS_ERR_NET_RECV_FAILED );
-    }
-
-    return ( ret );
-}
-
-/*
- * Read at most 'len' characters, blocking for at most 'timeout' ms
- */
-int mbedtls_net_recv_timeout( void *ctx, unsigned char *buf, size_t len,
-                              uint32_t timeout )
-{
-    int ret;
-    struct timeval tv;
-    fd_set read_fds;
-    int fd = ((mbedtls_net_context *) ctx)->fd;
-
-    if ( fd < 0 ) {
-        return ( MBEDTLS_ERR_NET_INVALID_CONTEXT );
-    }
-
-    FD_ZERO( &read_fds );
-    FD_SET( fd, &read_fds );
-
-    tv.tv_sec  = timeout / 1000;
-    tv.tv_usec = ( timeout % 1000 ) * 1000;
-
-    ret = select( fd + 1, &read_fds, NULL, NULL, timeout == 0 ? NULL : &tv );
-
-    /* Zero fds ready means we timed out */
-    if ( ret == 0 ) {
-        return ( MBEDTLS_ERR_SSL_TIMEOUT );
-    }
-
-    if ( ret < 0 ) {
-        if ( errno == EINTR ) {
-            return ( MBEDTLS_ERR_SSL_WANT_READ );
-        }
-
-        return ( MBEDTLS_ERR_NET_RECV_FAILED );
-    }
-
-    /* This call will not block */
-    return ( mbedtls_net_recv( ctx, buf, len ) );
-}
-
-/*
- * Write at most 'len' characters
- */
-int mbedtls_net_send( void *ctx, const unsigned char *buf, size_t len )
-{
-    int ret;
-    int fd = ((mbedtls_net_context *) ctx)->fd;
-
-    if ( fd < 0 ) {
-        return ( MBEDTLS_ERR_NET_INVALID_CONTEXT );
-    }
-
-    ret = (int) write( fd, buf, len );
-
-    if ( ret < 0 ) {
-        if ( net_would_block( ctx ) != 0 ) {
-            return ( MBEDTLS_ERR_SSL_WANT_WRITE );
-        }
-
-        if ( errno == EPIPE || errno == ECONNRESET ) {
-            return ( MBEDTLS_ERR_NET_CONN_RESET );
-        }
-
-        if ( errno == EINTR ) {
-            return ( MBEDTLS_ERR_SSL_WANT_WRITE );
-        }
-
-        return ( MBEDTLS_ERR_NET_SEND_FAILED );
-    }
-
-    return ( ret );
-}
-
-/*
- * Gracefully close the connection
- */
-void mbedtls_net_free( mbedtls_net_context *ctx )
-{
-    if ( ctx->fd == -1 ) {
-        return;
-    }
-
-    shutdown( ctx->fd, 2 );
-    close( ctx->fd );
-
-    ctx->fd = -1;
-}
 
 #endif /* MBEDTLS_NET_C */
-- 
2.17.1

